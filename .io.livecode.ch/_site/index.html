{% extends "base_livecode.html" %}

{% block title %}Interactive Scheme Mechanics{% endblock %}

{% block content %}
<script>
function livecode_html_extra(id) {
  return '<div class=boxit id='+'boxit-'+id+'></div>'
}
function livecode_process_data(id, data) {
  var tex = /<exp>\\boxit\{(.*?)\}<\/exp>/g;
  var m;
  var a = [];
  while ((m = tex.exec(data)) !== null) {
    a.push('<p>'+m[1]+'</p>');
  }
  if (a.length==0) return data;
  $('#boxit-'+id).html(a.join('\n'));
  MathJax.Hub.Queue(["Typeset",MathJax.Hub]);
  return data.replace(tex, "");
}
</script>
<div class="live hidden" id="lib">
(define (html-show-expression x)
  (display (string-append "&lt;exp&gt;" (expression->tex-string (simplify x)) "&lt;/exp&gt;"))
  x)
</div>

<p>
Scheme Mechanics, also known
as <a href="http://groups.csail.mit.edu/mac/users/gjs/6946/refman.txt"><code>SCMUTILS</code></a>, has been used in two books, <em>Structure and Interpretation of Classical Mechanics</em> (<a href="http://mitpress.mit.edu/sites/default/files/titles/content/sicm/book.html"><i class="fa fa-link"></i></a>), and <em>Functional Differential Geometry</em> (<a href="http://mitpress.mit.edu/books/functional-differential-geometry"><i class="fa fa-link"></i></a>, <a href="http://groups.csail.mit.edu/mac/users/gjs/6946/calculus-indexed.pdf"><i class="fa fa-file"></i></a>).
</p>

<h2>Exercise 1.9a (<a href="http://mitpress.mit.edu/sites/default/files/titles/content/sicm/book-Z-H-12.html#%_thm_1.9"><i class="fa fa-link"></i></a>)</h2>

<p>We derive the Lagrange equations for the following system. A particle of mass \(m\) moves in a two-dimensional potential \(V(x, y) = (x^2 + y^2)/2 + x^2 y - y^3/3\), where \(x\) and \(y\) are rectangular coordinates of the particle. A Lagrangian is \(L(t; x, y; v_x, v_y) = (1/2) m (v_x^2 + v_y^2) - V(x, y)\).</p>

<div class="live" id="ex" data-lib="lib">
(define (Lagrange-eq L q)
  (- (D (compose ((partial 2) L) (Gamma q)))
     (compose ((partial 1) L) (Gamma q))))

(define (V x y)
  (+ (/ (+ (square x) (square y)) 2)
     (* (square x) y)
     (- (/ (cube y) 3))))

(define ((L m) local)
  (let ((vx (ref (velocity local) 0))
        (vy (ref (velocity local) 1))
        ( x (ref (coordinate local) 0))
        ( y (ref (coordinate local) 1)))
    (- (/ (* m (+ (square vx) (square vy))) 2)
       (V x y))))

(define (q t)
  (up
   ((literal-function 'x) t)
   ((literal-function 'y) t)))

(html-show-expression ((Lagrange-eq (L 'm) q) 't)))</div>

<h2>Notation (<a href="http://mitpress.mit.edu/sites/default/files/titles/content/sicm/book-Z-H-79.html"><i class="fa fa-link"></i></a>)</h2>

<h3>Symbolic values (<a href="http://mitpress.mit.edu/sites/default/files/titles/content/sicm/book-Z-H-79.html#%_sec_Temp_449"><i class="fa fa-link"></i></a>)</h3>

<p>As in usual mathematical notation, arithmetic is extended to allow the use of symbols that represent unknown or incompletely specified mathematical objects. These symbols are manipulated as if they had values of a known type. By default, a Scheme symbol is assumed to represent a real number. So the expression <code>'a</code> is a literal Scheme symbol that represents an unspecified real number:
<div class="live" id="s1" data-lib="lib">
(html-show-expression
 ((compose cube sin) 'a))</div>
</p>

<p>The procedure <code>print-expression</code> (likewise <code>html-show-expression</code>) simplifies the expression, removes the type tags, and displays it in a readable form. We can use the simplifier to verify a trigonometric identity:
<div class="live" id="s2" data-lib="lib">
(html-show-expression
  ((- (+ (square sin) (square cos)) 1) 'a))</div>
</p>

<p>Just as it is useful to be able to manipulate symbolic numbers, it is useful to be able to manipulate symbolic functions. The procedure <code>literal-function</code> makes a procedure that acts as a function having no properties other than its name. By default, a literal function is defined to take one real argument and produce one real value. For example, we may want to work with a function \(f : \mathbb{R} \rightarrow \mathbb{R}\):
<div class="live" id="s3" data-lib="lib">
(html-show-expression
  ((literal-function 'f) 'x))

(html-show-expression
  ((compose (literal-function 'f) (literal-function 'g)) 'x))</div>
</p>

<p>We can also make literal functions of multiple, possibly structured arguments that return structured values. For example, to denote a literal function named g that takes two real arguments and returns a real value \((g : \mathbb{R} \times \mathbb{R} \rightarrow \mathbb{R})\) we may write:
<div class="live norun" id="def-g" data-lib="">
(define g (literal-function 'g (-> (X Real Real) Real)))</div>
<div class="live" id="s4" data-lib="lib def-g">
(html-show-expression (g 'x 'y))</div>

We may use such a literal function anywhere that an explicit function of the same type may be used.
</p>

<p>There is a whole language for describing the type of a literal function in terms of the number of arguments, the types of the arguments, and the types of the values. Here we describe a function that maps pairs of real numbers to real numbers with the expression <code>(-> (X Real Real) Real)</code>. Later we will introduce structured arguments and values and show extensions of literal functions to handle these.</p>

<h3>Tuples</h3>

<div class="live norun" id="def-s" data-lib="">
(define s (up 't (up 'x 'y) (down 'p_x 'p_y)))</div>

<h3>Derivatives (<a href="http://mitpress.mit.edu/sites/default/files/titles/content/sicm/book-Z-H-79.html#%_sec_Temp_452"><i class="fa fa-link"></i></a>)</h3>

<p>The derivative of a function \(f\) is a function, denoted by \(Df\). Our notational convention is that \(D\) is a high-precedence operator. Thus \(D\) operates on the adjacent function before any other application occurs: \(Df(x)\) is the same as \((Df)(x)\). Higher-order derivatives are described by exponentiating the derivative operator. Thus the \(n\)th derivative of a function \(f\) is notated as \(D^n f\).

<p>The Scheme procedure for producing the derivative of a function is named <code>D</code>. The derivative of the <code>sin</code> procedure is a procedure that computes <code>cos</code>:
<div class="live" id="d1" data-lib="lib">
(define derivative-of-sine (D sin))

(html-show-expression (derivative-of-sine 'x))</div>
</p>

<p>The derivative of a function \(f\) is the function \(Df\) whose value for a particular argument is something that can be multiplied by an increment \(\Delta x\) in the argument to get a linear approximation to the increment in the value of \(f\):
$$f(x + \Delta x) \approx f(x) + Df(x)\Delta x$$
</p>

<p>For example, let \(f\) be the function that cubes its argument \((f(x) = x^3)\); then \(Df\) is the function that yields three times the square of its argument \((Df(y) = 3y^2)\). So \(f(5) = 125\) and \(Df(5) = 75\). The value of \(f\) with argument \(x + \Delta x\) is
$$\begin{align}
f(x + \Delta x) &= (x + \Delta x)^3\\
                &= x^3 + 3x^2\Delta x + 3x\Delta x^2 + \Delta x^3
\end{align}$$
and
$$Df(x)\Delta x = 3x^2 \Delta x$$
So \(Df(x)\) multiplied by \(\Delta x\) gives us the term in \(f(x + \Delta x)\) that is linear in \(\Delta x\), providing a good approximation to \(f(x + \Delta x) - f(x)\) when \(\Delta x\) is small.
</p>

<p>Derivatives of compositions obey the chain rule:
$$D(f \circ g) = ((Df) \circ g) \cdot D g$$
So at \(x\),
$$(D(f \circ g))(x) = Df(g(x)) \cdot Dg(x)$$
</p>

<p>Derivatives are operators. An operator is like a function except that multiplication of operators is interpreted as composition, whereas multiplication of functions is multiplication of the values (see equation <a href="http://mitpress.mit.edu/sites/default/files/titles/content/sicm/book-Z-H-79.html#EQUATION_8.3">8.3</a>). If \(D\) were an ordinary function, then the rule for multiplication would imply that \(D^2 f\) would just be the product of \(Df\) with itself, which is not what is intended. Arithmetic is extended to allow manipulation of operators. A typical operator is \((D + 1)(D - 1) = D^2 - 1\), which subtracts a function from its second derivative. The \(1\) acts as the identity operator: When arithmetically combined with operators, a number is treated as an operator that multiplies its input by the number. Such an operator can be constructed and used in Scheme as follows:
<div class="live" id="d2" data-lib="lib">
(html-show-expression
  (((* (- D 1) (+ D 1)) (literal-function 'f)) 'x))</div>
</p>

<h3>Derivatives of functions of multiple arguments (<a href="http://mitpress.mit.edu/sites/default/files/titles/content/sicm/book-Z-H-79.html#%_sec_Temp_453"><i class="fa fa-link"></i></a>)</h3>

<p?The derivative generalizes to functions that take multiple arguments. The derivative of a real-valued function of multiple arguments is an object whose contraction with the tuple of increments in the arguments gives a linear approximation to the increment in the function's value.</p>

<p>A function of multiple arguments can be thought of as a function of an up tuple of those arguments. Thus an incremental argument tuple is an up tuple of components, one for each argument position. The derivative of such a function is a down tuple of the partial derivatives of the function with respect to each argument position.</p>

<p>Suppose we have a real-valued function \(g\) of two real-valued arguments, and we want to approximate the increment in the value of \(g\) from its value at \(x, y\). If the arguments are incremented by the tuple \((\Delta  x,\Delta y)\) we compute:
  $$\begin{align}
  Dg(x,y) \cdot (\Delta x, \Delta y)
  &= [\partial_0 g(x,y), \partial_1 g(x,y)] \cdot (\Delta x, \Delta y)\\
  &= [\partial_0 g(x,y) \Delta x, \partial_1 g(x,y) \Delta y]
  \end{align}$$
Using the two-argument literal function g defined <a href="#def-g">above</a>, we have:
<div class="live" id="d3" data-lib="lib def-g">
(html-show-expression ((D g) 'x 'y))</div>
</p>

<p>In general, partial derivatives are just the components of the derivative of a function that takes multiple arguments (or structured arguments or both; see below). So a partial derivative of a function is a composition of a component selector and the derivative of that function. Indeed:
$$\partial_0 g = I_0 \circ Dg$$
$$\partial_1 g = I_1 \circ Dg$$
Conretely, if
$$g(x,y) = x^3y^5$$
then
$$Dg(x,y) = [3x^2y^5,5x^3y^4]$$
and the first-order approximation of the increment for changing the arguments by \(\Delta x\) and \(\Delta y\) is
$$\begin{align}
g(x + \Delta x, y + \Delta y) - g(x,y)
&\approx [3x^2y^5,5x^3y^4] \cdot (\Delta x, \Delta y)\\
&= 3x^2y^5\Delta x + 5x^3y^4\Delta y
\end{align}$$
</p>

<p>
Partial derivatives of compositions also obey a chain rule:
$$\partial_i(f \circ g) = ((Df) \circ) \cdot \partial_i g$$
So if \(x\) is a tuple of arguments, then
$$(\partial_i(f \circ g))(x) = Df(g(x)) \cdot \partial_i g(x)$$
</p>

<p>Mathematical notation usually does not distinguish functions of multiple arguments and functions of the tuple of arguments. Let \(h((x, y)) = g(x, y)\). The function \(h\), which takes a tuple of arguments \(x\) and \(y\), is not distinguished from the function \(g\) that takes arguments \(x\) and \(y\). We use both ways of defining functions of multiple arguments. The derivatives of both kinds of functions are compatible for contraction with a tuple of increments to the arguments. Scheme comes in handy here:
<div class="live" id="d4" data-lib="lib def-g">
(define (h s)
  (g (ref s 0) (ref s 1)))

(html-show-expression
 (h (up 'x 'y)))

(html-show-expression ((D g) 'x 'y))

(html-show-expression ((D h) (up 'x 'y)))</div>
</p>

<p>A phase-space state function is a function of time, coordinates, and momenta. Let \(H\) be such a function. The value of \(H\) is \(H(t, ( x, y ), [ p_x , p_y ] )\) for time \(t\), coordinates \(( x, y )\) , and momenta [ p_x , p_y ]. Let \(s\) be the phase-space state tuple as <a href="#def-s">above</a>:
$$s = (t,(x,y),[p_x,p_y])$$
The value of \(H\) for argument tuple \(s\) is \(H(s)\). We use both ways of writing the value of \(H\).
</p>

<p>We often show a function of multiple arguments that include tuples by indicating the boundaries of the argument tuples with semicolons and separating their components with commas. If \(H\) is a function of phase-space states with arguments \(t\), \(( x, y )\), and \([ px, py ]\), we may write \(H(t; x, y ; px, py)\). This notation loses the up/down distinction, but our semicolon-and-comma notation is convenient and reasonably unambiguous.</p>

<p>The derivative of \(H\) is a function that produces an object that can be contracted with an increment in the argument structure to produce an increment in the function's value. The derivative is a down tuple of three partial derivatives. The first partial derivative is the partial derivative with respect to the numerical argument. The second partial derivative is a down tuple of partial derivatives with respect to each component of the up-tuple argument. The third partial derivative is an up tuple of partial derivatives with respect to each component of the down-tuple argument:
$$\begin{align}
DH(s) &= [&\partial_0 H(s)&, &\partial_1 H(s)&, &\partial_2 H(s)&]\\
&= [&\partial_0 H(s)&,&[\partial_{1,0} H(s), \partial_{1,1} H(s)]&, &(\partial_{2,0} H(s), \partial_{2,1} H(s))&]
\end{align}$$
where \(\partial_{1,0}\) indicates the partial derivative with respect to the first component (index \(0\)) of the second argument (index \(1\)) of the function, and so on. Indeed, \(\partial_z F = I_z \circ D F\) for any function \(F\) and access chain \(z\). So, if we let \(\Delta s\) be an incremental phase-space state tuple,
$$\Delta s = (\Delta t, (\Delta x, \Delta y), [\Delta p_x, \Delta p_y])$$
then
$$\begin{align}
  DH(s)\Delta s &=
  \partial_0 H(s) \Delta t \\
&+\partial_{1,0} H(s) \Delta x + \partial_{1,1} H(s) \Delta y\\
&+\partial_{2,0} H(s) \Delta p_x + \partial_{2,1} H(s) \Delta p_y
\end{align}$$
</p>

<p>Caution: Partial derivative operators with respect to different structured arguments generally do not commute.</p>

<p>In Scheme we must make explicit choices. We usually assume phase-space state functions are functions of the tuple. For example,
<div class="live" id="d5" data-lib="lib def-s">
(define H
  (literal-function 'H
    (-> (UP Real (UP Real Real) (DOWN Real Real)) Real)))

(html-show-expression
 (H s))

(html-show-expression
 ((D H) s))</div>
</p>

{% endblock %}
